using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MaybeResults;

// Based on https://andrewlock.net/exploring-dotnet-6-part-9-source-generator-updates-incremental-generators/
[Generator(LanguageNames.CSharp)]
public sealed class NoneGenerator : IIncrementalGenerator
{
    const string NoneAttribute = "MaybeResults.NoneAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. predicate: We only want to filter possible syntax targets for generation in a light way.
        // 2. transform: For syntax nodes that pass the first stage, we filter only the ones we care about.
        // 3. where: is an optimized version for the generators pipeline that filters null values.
        IncrementalValuesProvider<RecordDeclarationSyntax> recordDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsSyntaxTargetForGeneration(s),
                static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null)
            .Select(static (m, _) => m!);

        IncrementalValueProvider<(Compilation, ImmutableArray<RecordDeclarationSyntax>)> compilationAndClasses =
            context.CompilationProvider.Combine(recordDeclarations.Collect());

        context.RegisterSourceOutput(
            source: compilationAndClasses,
            static (spc, source) => Emit(context: spc, records: source.Item2));
    }

    //It's important for this first stage in the pipeline to be very fast and not to allocate, as it will be called a lot.
    // As best as I can tell, this predicate will be called every time you make a change in your editor.
    static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        => node is RecordDeclarationSyntax { AttributeLists.Count: > 0 };

    // Filter the syntax nodes to only the ones we care about.
    static RecordDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        // we know the node is a RecordDeclarationSyntax thanks to IsSyntaxTargetForGeneration
        RecordDeclarationSyntax recordDeclarationSyntax = (RecordDeclarationSyntax)context.Node;

        // loop through all the attributes on the record
        foreach (AttributeSyntax attributeSyntax in recordDeclarationSyntax.AttributeLists
            .SelectMany(attributeList => attributeList.Attributes))
        {
            string? fullName = context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol?.ContainingType.ToDisplayString();

            // Is the attribute the [LoggerMessage] attribute?
            if (fullName == NoneAttribute)
            {
                return recordDeclarationSyntax;
            }
        }

        // we didn't find the attribute we were looking for
        return null;
    }

    static void Emit(SourceProductionContext context, ImmutableArray<RecordDeclarationSyntax> records)
    {
        if (records.IsDefaultOrEmpty)
        {
            return; // nothing to do yet
        }

        IEnumerable<RecordDeclarationSyntax> distinctRecords = records.Distinct();

        foreach (RecordDeclarationSyntax record in distinctRecords)
        {
            string generatedCode = ToGeneratedCode(record);
            context.AddSource(
                hintName: $"{record.Identifier.Text}.g.cs",
                sourceText: SourceText.From(text: generatedCode, encoding: Encoding.UTF8));
        }
    }

    static string ToGeneratedCode(RecordDeclarationSyntax record)
    {
        string namespaceName = GetNamespace(record);
        string recordName = record.Identifier.Text;

        // Note: Do not use """ here, it will break the generated code.
        // language=cs
        return $@"// <auto-generated />
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MaybeResults;
using IMaybe = MaybeResults.IMaybe;

namespace {namespaceName}
{{
    public partial record {recordName} : INone
    {{
        /// <summary>
        /// Public constructor that takes two parameters the message and the details.
        /// This constructor it's provided for convenience but the equivalent factory method is recommend since it returns
        /// and IMaybe instead of the concrete type.
        /// </summary>
        /// <param name=""message"">A generic string that describes the problem.</param>
        /// <param name=""details"">A list of error details that are composed of a Code and a Detail.</param>
        public {recordName}(string message, IEnumerable<NoneDetail> details)
        {{
            Message = message ?? throw new ArgumentNullException(nameof(message));
            Details = details?.ToList() ?? throw new ArgumentNullException(nameof(details));
        }}

        /// <summary>
        /// Public constructor that only takes a message. Details are initialized to an empty array.
        /// This constructor it's provided for convenience but the equivalent factory method is recommend since it returns
        /// an IMaybe instead of the concrete type.
        /// </summary>
        /// <param name=""message"">A generic string that describes the problem.</param>
        public {recordName}(string message) : this(message, Array.Empty<NoneDetail>())
        {{
        }}

        /// <summary>
        /// This is the recommend way to create an instance of this class.
        /// It takes two parameters the message and the details.
        /// </summary>
        /// <param name=""message"">A generic string that describes the problem.</param>
        /// <param name=""details"">A list of details that are composed of a Code and a Description.</param>
        /// <returns>An instance of the class abstracted as an IMaybe.</returns>
        public static IMaybe Create(string message, IEnumerable<NoneDetail> details)
        {{
            return new {recordName}(message, details);
        }}

        /// <summary>
        /// This is the recommend way to create an instance of this class.
        /// It only takes a message. Error details are initialized to an empty array.
        /// </summary>
        /// <param name=""message"">A generic string that describes the problem.</param>
        /// <returns>An instance of the class abstracted as an IMaybe.</returns>
        public static IMaybe Create(string message)
        {{
            return new {recordName}(message);
        }}

        public string Message {{ get; }}

        public IReadOnlyCollection<NoneDetail> Details {{ get; }}

        /// <summary>
        /// Useful method to get a string representation of the error.
        /// It concatenates the Message with the Details list.
        /// </summary>
        /// <returns>A string representation of message and the details.</returns>
        public string GetDisplayMessage()
        {{
            StringBuilder sb = new(Message);
            foreach (NoneDetail detail in Details)
            {{
                sb = sb.Append(Environment.NewLine);
                sb = sb.Append(detail.Code).Append(value: "": "").Append(detail.Description);
            }}

            return sb.ToString();
        }}

        /// <summary>
        /// This method is used to cast Maybe<T> to a different type.
        /// You can find examples on how it's used in the extension methods for Map, FlatMap and Action.
        /// https://github.com/wtorricos/Results/blob/main/src/MaybeResults/MaybeExtensions.cs
        ///
        /// For example:
        ///     <![CDATA[
        ///     IMaybe<string> GetMaybe(int value)
        ///     {{
        ///         IMaybe<int> intMaybe = Maybe.Create(value);
        ///
        ///         return intMaybe switch
        ///         {{
        ///              Some<int> success => Maybe.Create(success.Value.ToString()),
        ///
        ///              // In case of none we need to cast it to comply with the method signature.
        ///              INone error => error.Cast<string>(),
        ///         }}
        ///     }}
        ///     ]]>
        /// </summary>
        /// <typeparam name=""TOut"">The type to cast to.</typeparam>
        /// <returns>The same result but with a different type parameter.</returns>
        public IMaybe<TOut> Cast<TOut>()
        {{
            return {recordName}<TOut>.Create(Message, Details);
        }}

        /// <summary>
        /// <![CDATA[ Executes onSome when successful and onNone when not successful. ]]>
        /// </summary>
        public IMaybe Match(Func<IMaybe> onSome, Action<INone> onNone = null)
        {{
            if(onNone != null)
            {{
                onNone.Invoke(this);
            }}
            return this;
        }}

        /// <summary>
        /// <![CDATA[ Executes onSome when successful and onNone when not successful. ]]>
        /// </summary>
        public IMaybe<TResult> Match<TResult>(Func<TResult> onSome, Action<INone> onNone = null)
        {{
            if(onNone != null)
            {{
                onNone.Invoke(this);
            }}
            return Cast<TResult>();
        }}

        /// <summary>
        /// <![CDATA[ Executes onSome when successful and onNone when not successful. ]]>
        /// </summary>
        public Task<IMaybe> Match(Func<Task<IMaybe>> onSome, Action<INone> onNone = null)
        {{
            if(onNone != null)
            {{
                onNone.Invoke(this);
            }}
            return Task.FromResult<IMaybe>(this);
        }}

        /// <summary>
        /// <![CDATA[ Executes onSome when successful and onNone when not successful. ]]>
        /// </summary>
        public Task<IMaybe<TResult>> Match<TResult>(Func<Task<TResult>> onSome, Action<INone> onNone = null)
        {{
            if(onNone != null)
            {{
                onNone.Invoke(this);
            }}
            return Task.FromResult(Cast<TResult>());
        }}
    }}

    public partial record {recordName}<T> : INone<T>
    {{
        /// <summary>
        /// Public constructor that takes two parameters the message and the details.
        /// This constructor it's provided for convenience but the equivalent factory method is recommend since it returns
        /// an IMaybe instead of the concrete type.
        /// </summary>
        /// <param name=""message"">A generic string that describes the problem.</param>
        /// <param name=""details"">A list of details that are composed of a Code and a Description.</param>
        public {recordName}(string message, IEnumerable<NoneDetail> details)
        {{
            Message = message ?? throw new ArgumentNullException(nameof(message));
            Details = details?.ToList() ?? throw new ArgumentNullException(nameof(details));
        }}

        /// <summary>
        /// Public constructor that only takes a message. Error details are initialized to an empty array.
        /// This constructor it's provided for convenience but the equivalent factory method is recommend since it returns
        /// an IMaybe instead of the concrete type.
        /// </summary>
        /// <param name=""message"">A generic string that describes the problem.</param>
        public {recordName}(string message) : this(message, Array.Empty<NoneDetail>())
        {{
        }}

        /// <summary>
        /// This is the recommend way to create an instance of this class.
        /// It takes two parameters the message and the details.
        /// </summary>
        /// <param name=""message"">A generic string that describes the problem.</param>
        /// <param name=""details"">A list of error details that are composed of a Code and a Description.</param>
        /// <returns>An instance of the class abstracted as an IMaybe.</returns>
        public static IMaybe<T> Create(string message, IEnumerable<NoneDetail> details)
        {{
            return new {recordName}<T>(message, details);
        }}

        /// <summary>
        /// This is the recommend way to create an instance of this class.
        /// It only takes a message. Error details are initialized to an empty array.
        /// </summary>
        /// <param name=""message"">A generic string that describes the problem.</param>
        /// <returns>An instance of the class abstracted as an IMaybe.</returns>
        public static IMaybe<T> Create(string message)
        {{
            return new {recordName}<T>(message);
        }}

        public string Message {{ get; }}

        public IReadOnlyCollection<NoneDetail> Details {{ get; }}

        /// <summary>
        /// Useful method to get a string representation of the error.
        /// It concatenates the Message with the Error list.
        /// </summary>
        /// <returns>A string representation of the message and the details.</returns>
        public string GetDisplayMessage()
        {{
            StringBuilder sb = new(Message);
            foreach (NoneDetail detail in Details)
            {{
                sb = sb.Append(Environment.NewLine);
                sb = sb.Append(detail.Code).Append(value: "": "").Append(detail.Description);
            }}

            return sb.ToString();
        }}

        /// <summary>
        /// This method is used to cast the result to a different type.
        /// You can find examples on how it's used in the extension methods for Map, FlatMap and Action.
        /// https://github.com/wtorricos/Results/blob/main/src/MaybeResults/MaybeExtensions.cs
        ///
        /// For example:
        ///     <![CDATA[
        ///     IMaybe<string> GetMaybe(int value)
        ///     {{
        ///         IMaybe<int> intMaybe = Maybe.Create(value);
        ///
        ///         return intMaybe switch
        ///         {{
        ///              Some<int> success => Maybe.Create(success.Value.ToString()),
        ///
        ///              // In the case of an error we need to cast it to comply with the method signature.
        ///              INone error => error.Cast<string>(),
        ///         }}
        ///     }}
        ///     ]]>
        /// </summary>
        /// <typeparam name=""TOut"">The type to cast to.</typeparam>
        /// <returns>The same result but with a different type parameter.</returns>
        public IMaybe<TOut> Cast<TOut>()
        {{
            return {recordName}<TOut>.Create(Message, Details);
        }}

        /// <summary>
        /// <![CDATA[ Method that allows us to go from IMaybe<T> to IMaybe. ]]>
        /// </summary>
        /// <returns>An IMaybe.</returns>
        public IMaybe ToMaybe()
        {{
            return {recordName}.Create(Message, Details);
        }}

        /// <summary>
        /// <![CDATA[ Executes onSome when successful and onNone when not successful. ]]>
        /// </summary>
        public IMaybe Match(Func<T, IMaybe> onSome, Action<INone<T>> onNone = null)
        {{
            if(onNone != null)
            {{
                onNone.Invoke(this);
            }}
            return this;
        }}

        /// <summary>
        /// <![CDATA[ Executes onSome when successful and onNone when not successful. ]]>
        /// </summary>
        public IMaybe Match(Func<IMaybe> onSome, Action<INone> onNone = null)
        {{
            if(onNone != null)
            {{
                onNone.Invoke(this);
            }}
            return this;
        }}

        /// <summary>
        /// <![CDATA[ Executes onSome when successful and onNone when not successful. ]]>
        /// </summary>
        public IMaybe<TResult> Match<TResult>(Func<TResult> onSome, Action<INone> onNone = null)
        {{
            if(onNone != null)
            {{
                onNone.Invoke(this);
            }}
            return Cast<TResult>();
        }}

        /// <summary>
        /// <![CDATA[ Executes onSome when successful and onNone when not successful. ]]>
        /// </summary>
        public Task<IMaybe> Match(Func<Task<IMaybe>> onSome, Action<INone> onNone = null)
        {{
            if(onNone != null)
            {{
                onNone.Invoke(this);
            }}
            return Task.FromResult<IMaybe>(this);
        }}

        /// <summary>
        /// <![CDATA[ Executes onSome when successful and onNone when not successful. ]]>
        /// </summary>
        public Task<IMaybe<TResult>> Match<TResult>(Func<Task<TResult>> onSome, Action<INone> onNone = null)
        {{
            if(onNone != null)
            {{
                onNone.Invoke(this);
            }}
            return Task.FromResult(Cast<TResult>());
        }}

        /// <summary>
        /// <![CDATA[ Executes onSome when successful and onNone when not successful. ]]>
        /// </summary>
        public IMaybe<TResult> Match<TResult>(Func<T, TResult> onSome, Action<INone<T>> onNone = null)
        {{
            if(onNone != null)
            {{
                onNone.Invoke(this);
            }}
            return Cast<TResult>();
        }}

        /// <summary>
        /// <![CDATA[ Executes onSome when successful and onNone when not successful. ]]>
        /// </summary>
        public Task<IMaybe<TResult>> Match<TResult>(Func<T, Task<TResult>> onSome, Action<INone<T>> onNone = null)
        {{
            if(onNone != null)
            {{
                onNone.Invoke(this);
            }}
            return Task.FromResult(Cast<TResult>());
        }}
    }}
}}
";
    }

    // Taken from https://andrewlock.net/creating-a-source-generator-part-5-finding-a-type-declarations-namespace-and-type-hierarchy/#finding-the-namespace-for-a-class-syntax
    // determine the namespace the class/enum/struct is declared in, if any
    static string GetNamespace(BaseTypeDeclarationSyntax syntax)
    {
        // If we don't have a namespace at all we'll return an empty string
        // This accounts for the "default namespace" case
        string nameSpace = string.Empty;

        // Get the containing syntax node for the type declaration
        // (could be a nested type, for example)
        SyntaxNode? potentialNamespaceParent = syntax.Parent;

        // Keep moving "out" of nested classes etc until we get to a namespace
        // or until we run out of parents
        while (potentialNamespaceParent is not null
            and not NamespaceDeclarationSyntax
            and not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        // Build up the final namespace by looping until we no longer have a namespace declaration
        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            // We have a namespace. Use that as the type
            nameSpace = namespaceParent.Name.ToString();

            // Keep moving "out" of the namespace declarations until we
            // run out of nested namespace declarations
            while (true)
            {
                if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
                {
                    break;
                }

                // Add the outer namespace as a prefix to the final namespace
                nameSpace = $"{namespaceParent.Name}.{nameSpace}";
                namespaceParent = parent;
            }
        }

        // return the final namespace
        return nameSpace;
    }
}
