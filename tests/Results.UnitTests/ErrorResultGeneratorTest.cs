using System.Collections;
using System.Collections.Immutable;
using System.Reflection;
using System.Runtime;
using System.Runtime.InteropServices;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Results.UnitTests;

// Documentation on testing generators can be found here:
// https://github.com/dotnet/roslyn/blob/main/docs/features/source-generators.cookbook.md#unit-testing-of-generators
public sealed class ErrorResultGeneratorTest
{
    [Test(Description = "Records with the ErrorResult attribute should generates the expected code")]
    public void CodeIsGenerated()
    {
        Compilation inputCompilation = CreateCompilation(
            source: """
            using Results;

            namespace MyCode
            {
                public class Program
                {
                    public static void Main(string[] args)
                    {
                    }
                }

                [ErrorResult]
                public sealed partial record MyError
                {
                }
            }
            """);

        // directly create an instance of the generator
        // (Note: in the compiler this is loaded from an assembly, and created via reflection at runtime)
        ErrorResultGenerator generator = new();

        // Create the driver that will control the generation, passing in our generator
        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);

        // Run the generation pass
        // Note: the generator driver itself is immutable, and all calls return
        // an updated version of the driver that you should use for subsequent calls.
        driver = driver.RunGeneratorsAndUpdateCompilation(
            inputCompilation,
            out Compilation outputCompilation,
            out ImmutableArray<Diagnostic> diagnostics);

        // Assert the resulting compilation:
        // there were no diagnostics created by the generators
        diagnostics.IsEmpty.Should().BeTrue();
        // we have two syntax trees, the original 'user' provided one, and the one added by the generator
        outputCompilation.SyntaxTrees.Count().Should().Be(expected: 2);
        // verify the compilation with the added source has no diagnostics (this means there are no problems)
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        // Get the results:
        GeneratorDriverRunResult runResult = driver.GetRunResult();

        // The runResult contains the combined results of all generators passed to the driver
        runResult.Diagnostics.Should().BeEmpty();
        string actualGenerated = runResult.GeneratedTrees.Single().ToString();
        actualGenerated.Should().Be(
            expected:
            """
            // <auto-generated />
            using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            using Results;

            namespace MyCode
            {
                public partial record MyError : IErrorResult
                {
                    /// <summary>
                    /// Public constructor that takes two parameters the message and the errors.
                    /// This constructor it's provided for convenience but the equivalent factory method is recommend since it returns
                    /// and IResult instead of the concrete type.
                    /// </summary>
                    /// <param name="message">A generic string that describes the problem.</param>
                    /// <param name="errors">A list of error details that are composed of a Code and a Detail.</param>
                    public MyError(string message, IEnumerable<ErrorResultDetail> errors)
                    {
                        Message = message ?? throw new ArgumentNullException(nameof(message));
                        Errors = errors?.ToList() ?? throw new ArgumentNullException(nameof(errors));
                    }

                    /// <summary>
                    /// Public constructor that only takes a message. Error details are initialized to an empty array.
                    /// This constructor it's provided for convenience but the equivalent factory method is recommend since it returns
                    /// and IResult instead of the concrete type.
                    /// </summary>
                    /// <param name="message">A generic string that describes the problem.</param>
                    public MyError(string message) : this(message, Array.Empty<ErrorResultDetail>())
                    {
                    }

                    /// <summary>
                    /// This is the recommend way to create an instance of this class.
                    /// It takes two parameters the message and the errors.
                    /// </summary>
                    /// <param name="message">A generic string that describes the problem.</param>
                    /// <param name="errors">A list of error details that are composed of a Code and a Detail.</param>
                    /// <returns>An instance of the class abstracted as an IResult.</returns>
                    public static IResult Create(string message, IEnumerable<ErrorResultDetail> errors)
                    {
                        return new MyError(message, errors);
                    }

                    /// <summary>
                    /// This is the recommend way to create an instance of this class.
                    /// It only takes a message. Error details are initialized to an empty array.
                    /// </summary>
                    /// <param name="message">A generic string that describes the problem.</param>
                    /// <returns>An instance of the class abstracted as an IResult.</returns>
                    public static IResult Create(string message)
                    {
                        return new MyError(message);
                    }

                    public string Message { get; }

                    public IReadOnlyCollection<ErrorResultDetail> Errors { get; }

                    /// <summary>
                    /// Useful method to get a string representation of the error.
                    /// It concatenates the Message with the Error list.
                    /// </summary>
                    /// <returns>A string representation of the error.</returns>
                    public string GetDisplayMessage()
                    {
                        StringBuilder sb = new(Message);
                        foreach (ErrorResultDetail detail in Errors)
                        {
                            sb = sb.Append(Environment.NewLine);
                            sb = sb.Append(detail.Code).Append(value: ": ").Append(detail.Details);
                        }

                        return sb.ToString();
                    }

                    /// <summary>
                    /// This method is used to cast the result to a different type.
                    /// You can find examples on how it's used in the extension methods for Map, FlatMap and Action.
                    /// https://github.com/wtorricos/Results/blob/main/src/Results/ResultExtensions.cs
                    ///
                    /// For example:
                    ///     <![CDATA[
                    ///     IResult<string> GetResult(int value)
                    ///     {
                    ///         IResult<int> intResult = Result.Success(value);
                    ///
                    ///         return intResult switch
                    ///         {
                    ///              SuccessResult<int> success => Result.Success(success.Data.ToString()),
                    ///
                    ///              // In the case of an error we need to cast it to comply with the method signature.
                    ///              IErrorResult error => error.Cast<string>(),
                    ///         }
                    ///     }
                    ///     ]]>
                    /// </summary>
                    /// <typeparam name="TOut">The type to cast to.</typeparam>
                    /// <returns>The same error but with a different type parameter.</returns>
                    public IResult<TOut> Cast<TOut>()
                    {
                        return MyError<TOut>.Create(Message, Errors);
                    }
                }

                public partial record MyError<T> : IErrorResult<T>
                {
                    /// <summary>
                    /// Public constructor that takes two parameters the message and the errors.
                    /// This constructor it's provided for convenience but the equivalent factory method is recommend since it returns
                    /// and IResult instead of the concrete type.
                    /// </summary>
                    /// <param name="message">A generic string that describes the problem.</param>
                    /// <param name="errors">A list of error details that are composed of a Code and a Detail.</param>
                    public MyError(string message, IEnumerable<ErrorResultDetail> errors)
                    {
                        Message = message ?? throw new ArgumentNullException(nameof(message));
                        Errors = errors?.ToList() ?? throw new ArgumentNullException(nameof(errors));
                    }

                    /// <summary>
                    /// Public constructor that only takes a message. Error details are initialized to an empty array.
                    /// This constructor it's provided for convenience but the equivalent factory method is recommend since it returns
                    /// and IResult instead of the concrete type.
                    /// </summary>
                    /// <param name="message">A generic string that describes the problem.</param>
                    public MyError(string message) : this(message, Array.Empty<ErrorResultDetail>())
                    {
                    }

                    /// <summary>
                    /// This is the recommend way to create an instance of this class.
                    /// It takes two parameters the message and the errors.
                    /// </summary>
                    /// <param name="message">A generic string that describes the problem.</param>
                    /// <param name="errors">A list of error details that are composed of a Code and a Detail.</param>
                    /// <returns>An instance of the class abstracted as an IResult.</returns>
                    public static IResult<T> Create(string message, IEnumerable<ErrorResultDetail> errors)
                    {
                        return new MyError<T>(message, errors);
                    }

                    /// <summary>
                    /// This is the recommend way to create an instance of this class.
                    /// It only takes a message. Error details are initialized to an empty array.
                    /// </summary>
                    /// <param name="message">A generic string that describes the problem.</param>
                    /// <returns>An instance of the class abstracted as an IResult.</returns>
                    public static IResult<T> Create(string message)
                    {
                        return new MyError<T>(message);
                    }

                    public string Message { get; }

                    public IReadOnlyCollection<ErrorResultDetail> Errors { get; }

                    /// <summary>
                    /// Useful method to get a string representation of the error.
                    /// It concatenates the Message with the Error list.
                    /// </summary>
                    /// <returns>A string representation of the error.</returns>
                    public string GetDisplayMessage()
                    {
                        StringBuilder sb = new(Message);
                        foreach (ErrorResultDetail detail in Errors)
                        {
                            sb = sb.Append(Environment.NewLine);
                            sb = sb.Append(detail.Code).Append(value: ": ").Append(detail.Details);
                        }

                        return sb.ToString();
                    }

                    /// <summary>
                    /// This method is used to cast the result to a different type.
                    /// You can find examples on how it's used in the extension methods for Map, FlatMap and Action.
                    /// https://github.com/wtorricos/Results/blob/main/src/Results/ResultExtensions.cs
                    ///
                    /// For example:
                    ///     <![CDATA[
                    ///     IResult<string> GetResult(int value)
                    ///     {
                    ///         IResult<int> intResult = Result.Success(value);
                    ///
                    ///         return intResult switch
                    ///         {
                    ///              SuccessResult<int> success => Result.Success(success.Data.ToString()),
                    ///
                    ///              // In the case of an error we need to cast it to comply with the method signature.
                    ///              IErrorResult error => error.Cast<string>(),
                    ///         }
                    ///     }
                    ///     ]]>
                    /// </summary>
                    /// <typeparam name="TOut">The type to cast to.</typeparam>
                    /// <returns>The same error but with a different type parameter.</returns>
                    public IResult<TOut> Cast<TOut>()
                    {
                        return MyError<TOut>.Create(Message, Errors);
                    }

                    /// <summary>
                    /// <![CDATA[ Method that allows us to go from IResult<T> to IResult. ]]>
                    /// </summary>
                    /// <returns>An IResult.</returns>
                    public IResult ToResult()
                    {
                        return MyError.Create(Message, Errors);
                    }
                }
            }

            """);
    }

    static Compilation CreateCompilation(string source)
        => CSharpCompilation.Create(
            assemblyName: "compilation",
            new[]
            {
                CSharpSyntaxTree.ParseText(source)
            },
            new[]
            {
                MetadataReference.CreateFromFile(typeof(ErrorResultGenerator).GetTypeInfo().Assembly.Location),
                MetadataReference.CreateFromFile(Path.Combine(RuntimeEnvironment.GetRuntimeDirectory(),
                    path2: "netstandard.dll")),
                MetadataReference.CreateFromFile(typeof(object).GetTypeInfo().Assembly.Location),
                MetadataReference.CreateFromFile(typeof(Enumerable).GetTypeInfo().Assembly.Location),
                MetadataReference.CreateFromFile(
                    Path.Combine(
                        Path.GetDirectoryName(typeof(IEnumerator).GetTypeInfo().Assembly.Location)!,
                        path2: "System.Runtime.dll")),
                MetadataReference.CreateFromFile(
                    Path.Combine(
                        Path.GetDirectoryName(typeof(GCSettings).GetTypeInfo().Assembly.Location)!,
                        path2: "System.Collections.dll"))
            },
            new CSharpCompilationOptions(OutputKind.ConsoleApplication));
}
